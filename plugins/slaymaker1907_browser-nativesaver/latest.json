{"title":"$:/plugins/slaymaker1907/browser-nativesaver","name":"HTML Native File System Saver","description":"TW saver which saves to the file system using the File System Access API.","author":"Dyllon Gagnier","dependents":"","list":"","plugin-type":"plugin","source":"https://github.com/slaymaker1907/TW5-fsa-saver","version":"0.7.1","core-version":">=5.2.1","type":"application/json","text":"{\"tiddlers\":{\"$:/plugins/slaymaker1907/browser-nativesaver/saver-controller.js\":{\"title\":\"$:/plugins/slaymaker1907/browser-nativesaver/saver-controller.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/slaymaker1907/browser-nativesaver/saver-controller.js\\r\\ntype: application/javascript\\r\\nmodule-type: widget\\r\\n\\r\\nProvides a message catcher for manipulating the native saver.\\r\\n\\r\\n\\\\*/\\r\\nconst Widget = require(\\\"$:/core/modules/widgets/widget.js\\\").widget;\\r\\nconst Saver = require(\\\"$:/plugins/slaymaker1907/browser-nativesaver/saver.js\\\");\\r\\n// declare const require: (name: \\\"$:/core/modules/widgets/widget.js\\\") => {widget: {new(): IWidget}}\\r\\n// \\t| ((name: \\\"$:/plugins/slaymaker1907/browser-nativesaver/saver.js\\\") => {widget: {new(): IWidget}});\\r\\nfunction isObjectEmpty(obj) {\\r\\n    for (let _key in obj) {\\r\\n        return false;\\r\\n    }\\r\\n    return true;\\r\\n}\\r\\nclass SaverControllerWidget extends Widget {\\r\\n    constructor(parseTreeNode, options) {\\r\\n        super();\\r\\n        this.initialise(parseTreeNode, options);\\r\\n    }\\r\\n    render(parent, nextSibling) {\\r\\n        this.parentDomNode = parent;\\r\\n        this.computeAttributes();\\r\\n        this.execute();\\r\\n        this.addEventListener(\\\"ns-reset-file-saver\\\", () => {\\r\\n            Saver.getCurrentSaver().reset();\\r\\n            return false;\\r\\n        });\\r\\n        // Only needed for listeners\\r\\n        this.renderChildren(parent, nextSibling);\\r\\n    }\\r\\n    execute() {\\r\\n        // Compute internal state here\\r\\n        // this.actionMessage = this.getAttribute(\\\"$message\\\");\\r\\n        this.makeChildWidgets();\\r\\n    }\\r\\n    refresh(changedTiddlers) {\\r\\n        const changed = this.computeAttributes();\\r\\n        if (!isObjectEmpty(changed)) {\\r\\n            this.refreshSelf();\\r\\n            return true;\\r\\n        }\\r\\n        else {\\r\\n            return this.refreshChildren(changedTiddlers);\\r\\n        }\\r\\n    }\\r\\n}\\r\\nmodule.exports = {\\r\\n    nativesavercontroller: SaverControllerWidget\\r\\n};\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"widget\"},\"$:/plugins/slaymaker1907/browser-nativesaver/saver.js\":{\"title\":\"$:/plugins/slaymaker1907/browser-nativesaver/saver.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/slaymaker1907/browser-nativesaver/saver.js\\r\\ntype: application/javascript\\r\\nmodule-type: saver\\r\\n\\r\\nMain module for saving to a file from a browser. Only Chromium based browsers currently\\r\\nsupport the necessary APIs.\\r\\n\\r\\n\\\\*/\\r\\nvar SaverCapability;\\r\\n(function (SaverCapability) {\\r\\n    SaverCapability[\\\"Save\\\"] = \\\"save\\\";\\r\\n    SaverCapability[\\\"AutoSave\\\"] = \\\"autosave\\\";\\r\\n    SaverCapability[\\\"Download\\\"] = \\\"download\\\";\\r\\n})(SaverCapability || (SaverCapability = {}));\\r\\nvar SaverStyle;\\r\\n(function (SaverStyle) {\\r\\n    SaverStyle[\\\"SingleFileVersionBackup\\\"] = \\\"single-file-version-backup\\\";\\r\\n    SaverStyle[\\\"SingleFile\\\"] = \\\"single-file\\\";\\r\\n})(SaverStyle || (SaverStyle = {}));\\r\\nfunction constructEnumPredicate(enumClass) {\\r\\n    const reverseMapping = {};\\r\\n    for (const enumVal in enumClass) {\\r\\n        const enumStr = enumClass[enumVal];\\r\\n        reverseMapping[enumStr] = true;\\r\\n    }\\r\\n    function result(maybeEnum) {\\r\\n        return !!reverseMapping[maybeEnum];\\r\\n    }\\r\\n    return result;\\r\\n}\\r\\nconst isSaverStyle = constructEnumPredicate(SaverStyle);\\r\\nlet problemEncountered = false;\\r\\nconst PLUGIN_NAME = \\\"slaymaker1907/browser-nativesaver\\\";\\r\\nconst BASE_TIDDLER_PATH = `$:/plugins/${PLUGIN_NAME}`;\\r\\nconst PLUGIN_SETTINGS_DATA = `${BASE_TIDDLER_PATH}/settings-data`;\\r\\nconst PLUGIN_SETTINGS_TIDDLER = `${BASE_TIDDLER_PATH}/settings`;\\r\\nconst ENABLE_LOGGING_FIELD = \\\"enable-logging?\\\";\\r\\nconst ENABLE_SAVER_FIELD = \\\"enable-saver?\\\";\\r\\nconst SAVER_STYLE_FIELD = \\\"save-style\\\";\\r\\nconst ALLOW_INDEXED_DB_FIELD = \\\"allow-indexedDB?\\\";\\r\\nconst WIKI_FILENAME_FIELD = \\\"wiki-file-name\\\";\\r\\nconst SHOW_WELCOME_MODAL_FIELD = \\\"show-welcome-modal?\\\";\\r\\nconst YES = \\\"yes\\\";\\r\\nconst UNIQUE_PLUGIN_ID = \\\"QqiTNHy4qkN9TtIYbd5i\\\";\\r\\nconst WELCOME_PAGE = \\\"$:/plugins/slaymaker1907/browser-nativesaver/welcome\\\";\\r\\nconst BACKUP_FOLDER_NAME = \\\"backups\\\";\\r\\nlet logDebug = console.log;\\r\\nconst setupLogging = (wiki) => {\\r\\n    try {\\r\\n        const tiddler = wiki.getTiddler(PLUGIN_SETTINGS_DATA);\\r\\n        if (!tiddler) {\\r\\n            return;\\r\\n        }\\r\\n        const fieldValue = tiddler.getFieldString(ENABLE_LOGGING_FIELD);\\r\\n        if (fieldValue === YES) {\\r\\n            logDebug = console.log;\\r\\n        }\\r\\n        else {\\r\\n            logDebug = () => { };\\r\\n        }\\r\\n    }\\r\\n    catch (err) {\\r\\n        console.error(\\\"Could not initialize logging due to error: %o\\\", err);\\r\\n    }\\r\\n};\\r\\nconst isEnabled = (wiki) => {\\r\\n    return wiki.getTiddler(PLUGIN_SETTINGS_DATA).getFieldString(ENABLE_SAVER_FIELD) === YES;\\r\\n};\\r\\nfunction getSaverStyle(wiki) {\\r\\n    try {\\r\\n        const maybeSaverStyle = wiki.getTiddler(PLUGIN_SETTINGS_DATA).getFieldString(SAVER_STYLE_FIELD);\\r\\n        if (isSaverStyle(maybeSaverStyle)) {\\r\\n            return maybeSaverStyle;\\r\\n        }\\r\\n        else {\\r\\n            logDebug(\\\"Input saver style [%s] is not recognized, using default of SingleFile.\\\", maybeSaverStyle);\\r\\n            return SaverStyle.SingleFile;\\r\\n        }\\r\\n    }\\r\\n    catch (err) {\\r\\n        console.error(\\\"Error checking if versioning is enabled, using single file style.\\\");\\r\\n        console.error(err);\\r\\n        return SaverStyle.SingleFile;\\r\\n    }\\r\\n}\\r\\n;\\r\\nconst isServedFromFS = () => {\\r\\n    try {\\r\\n        const protocol = window.location.protocol;\\r\\n        logDebug(\\\"TiddlyWiki location protocol is [%o]\\\", protocol);\\r\\n        return protocol.startsWith;\\r\\n    }\\r\\n    catch (err) {\\r\\n        logDebug(\\\"Error occurred trying to determine protocol for TiddlyWiki: %o\\\", err);\\r\\n        logDebug(\\\"Assuming that it is file:/ to maximimize security\\\");\\r\\n    }\\r\\n};\\r\\nfunction canUseIndexedDB(wiki) {\\r\\n    return !isServedFromFS() || wiki.getTiddler(PLUGIN_SETTINGS_DATA).getFieldString(ALLOW_INDEXED_DB_FIELD) === YES;\\r\\n}\\r\\n/**\\r\\n * Converts an IDBRequest to an equivalent Promise.\\r\\n */\\r\\nfunction idbRequestToPromise(request) {\\r\\n    return new Promise((resolve, reject) => {\\r\\n        request.onsuccess = () => {\\r\\n            try {\\r\\n                resolve(request.result);\\r\\n            }\\r\\n            catch (err) {\\r\\n                // This is possible only on incorrect API usage, but just want to be safe to avoid\\r\\n                // infinite loops.\\r\\n                reject(err);\\r\\n            }\\r\\n        };\\r\\n        request.onerror = () => {\\r\\n            reject(request.error);\\r\\n        };\\r\\n    });\\r\\n}\\r\\n/**\\r\\n * Return a Promise which will resolve when the transaction succeeds or\\r\\n * reject when it faild and/or aborts.\\r\\n */\\r\\nconst getTransactionCommitPromise = (transaction) => {\\r\\n    return new Promise((resolve, reject) => {\\r\\n        let errorSeen = false;\\r\\n        transaction.oncomplete = () => resolve();\\r\\n        const errorHandler = () => {\\r\\n            if (!errorSeen) {\\r\\n                errorSeen = true;\\r\\n                reject(transaction.error || \\\"Transaction aborted/failed\\\");\\r\\n            }\\r\\n        };\\r\\n        transaction.onerror = errorHandler;\\r\\n        transaction.onabort = errorHandler;\\r\\n    });\\r\\n};\\r\\nconst DB_VERSION = 1;\\r\\nconst DB_NAME = `FileHandles-${UNIQUE_PLUGIN_ID}`;\\r\\nconst DB_HANDLE_OBJECT_STORE_NAME = \\\"FileHandles\\\";\\r\\nconst CURRENT_FILE_HANDLE_NAME = \\\"CURRENT_FILE_HANDLE\\\";\\r\\nconst IDB_READWRITE = \\\"readwrite\\\";\\r\\nconst IDB_READONLY = \\\"readonly\\\";\\r\\nconst IDB_RELAXED = \\\"relaxed\\\";\\r\\nconst tryCreateHandleStore = async (wiki) => {\\r\\n    if (!window.indexedDB) {\\r\\n        const message = \\\"Cannot save file handle across browser sessions because your browser does not support IndexedDB.\\\";\\r\\n        logDebug(message);\\r\\n        return Promise.reject(message);\\r\\n    }\\r\\n    else if (!canUseIndexedDB(wiki)) {\\r\\n        const message = \\\"It is not secure to save sensitive data to IndexedDB when using the file:/ protocol.\\\";\\r\\n        logDebug(message);\\r\\n        logDebug(\\\"This is a security issue because anything served via file:/ share a single origin in Chromium browsers.\\\");\\r\\n        logDebug(\\\"See https://bugs.chromium.org/p/chromium/issues/detail?id=1202597#c3 for details.\\\");\\r\\n        return Promise.reject(message);\\r\\n    }\\r\\n    logDebug(\\\"Browser supports IndexedDB so will attempt to create/retrieve a DB for storing a file handle.\\\");\\r\\n    const dbOpenRequest = window.indexedDB.open(DB_NAME, DB_VERSION);\\r\\n    dbOpenRequest.onupgradeneeded = event => {\\r\\n        logDebug(\\\"Initializing file handle DB since received event %o\\\", event);\\r\\n        const db = dbOpenRequest.result;\\r\\n        // Don't specify keyPath or autoIncrement so that keys are stored separately from values which lets\\r\\n        // us store any kind of value.\\r\\n        const store = db.createObjectStore(DB_HANDLE_OBJECT_STORE_NAME);\\r\\n        logDebug(\\\"Successfully created store %o/%o\\\", DB_NAME, DB_HANDLE_OBJECT_STORE_NAME);\\r\\n        return store;\\r\\n    };\\r\\n    try {\\r\\n        const db = await idbRequestToPromise(dbOpenRequest);\\r\\n        logDebug(\\\"Successfully opened database for storing file handles %o.\\\", db);\\r\\n        return db;\\r\\n    }\\r\\n    catch (err) {\\r\\n        logDebug(\\\"Could not open database for storing file handles: %o\\\", err);\\r\\n        throw err;\\r\\n    }\\r\\n};\\r\\nconst requestFileHandle = async (startIn) => {\\r\\n    for (let i = 0; i < 2; i++) {\\r\\n        const result = await window.showSaveFilePicker({\\r\\n            types: [{\\r\\n                    description: \\\"HTML file\\\",\\r\\n                    accept: {\\r\\n                        \\\"text/html\\\": [\\r\\n                            \\\".html\\\",\\r\\n                            \\\".htm\\\"\\r\\n                        ]\\r\\n                    }\\r\\n                }],\\r\\n            id: UNIQUE_PLUGIN_ID,\\r\\n            startIn\\r\\n        });\\r\\n        logDebug(\\\"Received file handle: %o\\\", result);\\r\\n        if (result.kind === \\\"file\\\") {\\r\\n            return result;\\r\\n        }\\r\\n        alert(\\\"File input must be a file, not a directory.\\\");\\r\\n    }\\r\\n    return await Promise.reject(\\\"Could not get file for saving.\\\");\\r\\n};\\r\\nconst requestDirectoryHandle = async (startIn) => {\\r\\n    for (let i = 0; i < 2; i++) {\\r\\n        const result = await window.showDirectoryPicker({\\r\\n            id: UNIQUE_PLUGIN_ID,\\r\\n            startIn\\r\\n        });\\r\\n        logDebug(\\\"Received directory handle: %o\\\", result);\\r\\n        if (result.kind === \\\"directory\\\") {\\r\\n            return result;\\r\\n        }\\r\\n        alert(\\\"File input must be a directory, not a file.\\\");\\r\\n    }\\r\\n    return await Promise.reject(\\\"Could not get directory for saving.\\\");\\r\\n};\\r\\nconst getIndexedDBKey = async () => {\\r\\n    return CURRENT_FILE_HANDLE_NAME + (await hashToString(window.location.href));\\r\\n};\\r\\nasync function getCachedHandle(wiki, cacheable) {\\r\\n    let transaction;\\r\\n    let store;\\r\\n    let db;\\r\\n    const storageKey = await getIndexedDBKey();\\r\\n    logDebug(\\\"Computed storage key to be: [%s]\\\", storageKey);\\r\\n    try {\\r\\n        db = await tryCreateHandleStore(wiki);\\r\\n        transaction = db.transaction([DB_HANDLE_OBJECT_STORE_NAME], IDB_READONLY);\\r\\n        store = transaction.objectStore(DB_HANDLE_OBJECT_STORE_NAME);\\r\\n    }\\r\\n    catch (err) {\\r\\n        logDebug(\\\"Could not get handle store due to error, must request file location from user: %o\\\", err);\\r\\n        return await cacheable.requestNew();\\r\\n    }\\r\\n    // store must now be initialized\\r\\n    const requestAndStoreNewFile = async () => {\\r\\n        const handle = await cacheable.requestNew();\\r\\n        logDebug(\\\"Saving handle %o to object store to avoid requests in the future\\\", handle);\\r\\n        // Don't await this and just let it execute in background since it isn't really that\\r\\n        // important.\\r\\n        try {\\r\\n            // Have to get a new transaction because requestFileHandle puts us in a new event loop.\\r\\n            transaction = db.transaction([DB_HANDLE_OBJECT_STORE_NAME], IDB_READWRITE);\\r\\n            store = transaction.objectStore(DB_HANDLE_OBJECT_STORE_NAME);\\r\\n            idbRequestToPromise(store.put(handle, storageKey)).then(async () => {\\r\\n                await getTransactionCommitPromise(transaction);\\r\\n                logDebug(\\\"Successfully saved file handle %o to object store.\\\", handle);\\r\\n            }, err => {\\r\\n                logDebug(\\\"Could not save file handle %o to object store (user will have to select file once they refresh): %o\\\", handle, err);\\r\\n            });\\r\\n        }\\r\\n        catch (err) {\\r\\n            logDebug(\\\"Failed to initate save request for file hande due to error: %o\\\", err);\\r\\n        }\\r\\n        return handle;\\r\\n    };\\r\\n    try {\\r\\n        const maybeFileHandle = await idbRequestToPromise(store.get(storageKey));\\r\\n        if (!cacheable.oldIsValid(maybeFileHandle)) {\\r\\n            logDebug(\\\"No existing file handle found, must request new one\\\");\\r\\n            return await requestAndStoreNewFile();\\r\\n        }\\r\\n        // Explicitly request permission to readwrite to avoid permissions issues later on.\\r\\n        logDebug(\\\"Found a previous file handle so try to avoid duplicate requests to user for file location %o\\\", maybeFileHandle);\\r\\n        logDebug(\\\"Requesting permission for RW on file object.\\\");\\r\\n        const status = await maybeFileHandle.requestPermission({ mode: IDB_READWRITE }); // These strings happen to be the same for IDB and files.\\r\\n        logDebug(\\\"Requesting permission for RW on file returned status: %o\\\", status);\\r\\n        if (status !== \\\"granted\\\") {\\r\\n            throw Error(`RW on file was not granted, status of the permission is: [${status}]`);\\r\\n        }\\r\\n        logDebug(\\\"Successfully obtained RW permission on file system object.\\\");\\r\\n        return maybeFileHandle;\\r\\n    }\\r\\n    catch (err) {\\r\\n        logDebug(\\\"Could not get previous handle, must request a new one due to error: %o\\\", err);\\r\\n        return await requestAndStoreNewFile();\\r\\n    }\\r\\n}\\r\\nconst getFileHandle = (wiki, startHandle) => {\\r\\n    function isFileHandle(obj) {\\r\\n        return obj && obj.kind === \\\"file\\\";\\r\\n    }\\r\\n    return getCachedHandle(wiki, {\\r\\n        requestNew: () => requestFileHandle(startHandle),\\r\\n        oldIsValid: isFileHandle\\r\\n    });\\r\\n};\\r\\nconst getDirectoryHandle = async (wiki, startHandle) => {\\r\\n    function isDirectoryHandle(obj) {\\r\\n        return obj && obj.kind === \\\"directory\\\";\\r\\n    }\\r\\n    return getCachedHandle(wiki, {\\r\\n        requestNew: () => requestDirectoryHandle(startHandle),\\r\\n        oldIsValid: isDirectoryHandle\\r\\n    });\\r\\n};\\r\\n// Returns a string hash in hex for easy comparison and printing.\\r\\nasync function hashToString(data) {\\r\\n    let buffer;\\r\\n    if (typeof data === \\\"string\\\") {\\r\\n        const encoder = new TextEncoder();\\r\\n        buffer = encoder.encode(data);\\r\\n    }\\r\\n    else {\\r\\n        buffer = data;\\r\\n    }\\r\\n    // Adapted from example at https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest\\r\\n    const hashBytes = await window.crypto.subtle.digest(\\\"SHA-256\\\", buffer);\\r\\n    const hashArray = Array.from(new Uint8Array(hashBytes));\\r\\n    const hexChars = hashArray.map(byte => byte.toString(16));\\r\\n    // Pad in case hash is small.\\r\\n    return hexChars.join(\\\"\\\").padStart(64, \\\"0\\\");\\r\\n}\\r\\nasync function getWikiFileName(wiki) {\\r\\n    const explicitName = wiki.getTiddler(PLUGIN_SETTINGS_DATA).getFieldString(WIKI_FILENAME_FIELD);\\r\\n    if (!explicitName || explicitName.trim() === \\\"\\\") {\\r\\n        const wikiButtonFilename = wiki.getTiddler(\\\"$:/config/SaveWikiButton/Filename\\\");\\r\\n        const siteTitle = wiki.getTiddler(\\\"$:/SiteTitle\\\");\\r\\n        if (wikiButtonFilename) {\\r\\n            return wikiButtonFilename.getFieldString(\\\"text\\\").trim();\\r\\n        }\\r\\n        else if (siteTitle) {\\r\\n            return `${siteTitle.getFieldString(\\\"text\\\").trim()}.html`;\\r\\n        }\\r\\n        else {\\r\\n            return \\\"index.html\\\";\\r\\n        }\\r\\n    }\\r\\n    else {\\r\\n        return explicitName.trim();\\r\\n    }\\r\\n}\\r\\nclass FileSystemSaver {\\r\\n    constructor(wiki) {\\r\\n        this.wiki = wiki;\\r\\n        this.info = {\\r\\n            name: PLUGIN_NAME,\\r\\n            priority: 100000,\\r\\n            capabilities: [SaverCapability.Save, SaverCapability.AutoSave]\\r\\n        };\\r\\n        this.initError = null;\\r\\n        this.backupSaveProm = Promise.resolve();\\r\\n        setupLogging(wiki);\\r\\n        logDebug(\\\"Constructing a FileSystemSaver\\\");\\r\\n    }\\r\\n    userInteractionInit() {\\r\\n        if (this.fileHandle) {\\r\\n            return;\\r\\n        }\\r\\n        // const saverStyle = getSaverStyle(this.wiki);\\r\\n        if (getSaverStyle(this.wiki) === SaverStyle.SingleFile) {\\r\\n            logDebug(\\\"Attempting to get file handle.\\\");\\r\\n            this.fileHandle = getFileHandle(this.wiki);\\r\\n            this.fileHandle.catch(err => {\\r\\n                problemEncountered = true;\\r\\n                this.initError = err;\\r\\n                logDebug(\\\"Could not get file handle due to error: %o\\\", err);\\r\\n            });\\r\\n        }\\r\\n        else {\\r\\n            logDebug(\\\"Attempting to get directory handle.\\\");\\r\\n            this.dirHandle = getDirectoryHandle(this.wiki);\\r\\n            this.fileHandle = this.dirHandle.then(async (actualDirHandle) => {\\r\\n                const wikiFileName = await getWikiFileName(this.wiki);\\r\\n                logDebug(\\\"Filename of wiki is: %o\\\", wikiFileName);\\r\\n                return actualDirHandle.getFileHandle(wikiFileName, {\\r\\n                    create: true\\r\\n                });\\r\\n            });\\r\\n        }\\r\\n    }\\r\\n    async checkConsistency(newText) {\\r\\n        if (!this.shouldCheckConsistency()) {\\r\\n            logDebug(\\\"Skipping consistency check since it is disabled\\\");\\r\\n            return;\\r\\n        }\\r\\n        if (!this.prevPageHash) {\\r\\n            logDebug(\\\"No previous known hash to compare against\\\");\\r\\n            this.prevPageHash = hashToString(newText);\\r\\n            return;\\r\\n        }\\r\\n        const handle = await this.fileHandle;\\r\\n        logDebug(\\\"Reading current value to check consistency\\\");\\r\\n        const reader = await handle.getFile();\\r\\n        const currentText = await reader.text();\\r\\n        const currentHash = await hashToString(currentText);\\r\\n        const prevHash = await this.prevPageHash;\\r\\n        if (currentHash !== prevHash) {\\r\\n            logDebug(\\\"Expected hash to be [%s] but it is currently [%s]\\\", prevHash, currentHash);\\r\\n            problemEncountered = true;\\r\\n            const err = \\\"Previous page source does not match the current text\\\";\\r\\n            return Promise.reject(err);\\r\\n        }\\r\\n        logDebug(\\\"Previous value matches the current value so saving is safe\\\");\\r\\n        logDebug(\\\"Computing hash of text to save...\\\");\\r\\n        this.prevPageHash = hashToString(newText);\\r\\n        return {\\r\\n            fileHash: currentHash,\\r\\n            fileText: currentText\\r\\n        };\\r\\n    }\\r\\n    shouldCheckConsistency() {\\r\\n        return this.wiki.getTiddler(PLUGIN_SETTINGS_DATA).getFieldString(ENABLE_SAVER_FIELD) === YES;\\r\\n    }\\r\\n    async saveFile(text) {\\r\\n        const handle = await this.fileHandle;\\r\\n        if (this.shouldCheckConsistency()) {\\r\\n            await this.checkConsistency(text);\\r\\n        }\\r\\n        else {\\r\\n            logDebug(\\\"Skipping consistency check\\\");\\r\\n        }\\r\\n        logDebug(\\\"Creating writable...\\\");\\r\\n        const writable = await handle.createWritable();\\r\\n        logDebug(\\\"Created writable\\\");\\r\\n        try {\\r\\n            await writable.write(text);\\r\\n            logDebug(\\\"Wrote data successfully\\\");\\r\\n        }\\r\\n        finally {\\r\\n            await writable.close();\\r\\n            logDebug(\\\"Closed writable\\\");\\r\\n        }\\r\\n    }\\r\\n    async saveBackup(text) {\\r\\n        const textHashProm = hashToString(text);\\r\\n        const dirHandle = await this.dirHandle;\\r\\n        const backupDir = await dirHandle.getDirectoryHandle(BACKUP_FOLDER_NAME, {\\r\\n            create: true\\r\\n        });\\r\\n        const wikiFileName = await (await this.fileHandle).name;\\r\\n        const wikiBackupDir = await backupDir.getDirectoryHandle(wikiFileName, {\\r\\n            create: true\\r\\n        });\\r\\n        const textHash = await textHashProm;\\r\\n        const backupFileName = `${textHash}.html`;\\r\\n        logDebug(\\\"Backing up wiki file to %o\\\", backupFileName);\\r\\n        const backupFile = await wikiBackupDir.getFileHandle(backupFileName, {\\r\\n            create: true\\r\\n        });\\r\\n        const backupWriter = await backupFile.createWritable();\\r\\n        try {\\r\\n            await backupWriter.write(text);\\r\\n            logDebug(\\\"Wrote backup successfully\\\");\\r\\n        }\\r\\n        finally {\\r\\n            await backupWriter.close();\\r\\n        }\\r\\n    }\\r\\n    async saveWithDirBackup(text) {\\r\\n        // First start save to new folder since that doesn't overwrite anything.\\r\\n        const newBackupProm = this.saveBackup(text);\\r\\n        // Now wait for last backup to complete.\\r\\n        await this.backupSaveProm;\\r\\n        this.backupSaveProm = newBackupProm;\\r\\n        return this.saveFile(text);\\r\\n    }\\r\\n    save(text, method, callback) {\\r\\n        setupLogging(this.wiki);\\r\\n        if (!isEnabled(this.wiki)) {\\r\\n            logDebug(\\\"Not saving since this saver is not enabled.\\\");\\r\\n            return false;\\r\\n        }\\r\\n        logDebug(\\\"Saving with method %o\\\", method);\\r\\n        this.userInteractionInit();\\r\\n        if (this.initError !== null) {\\r\\n            logDebug(\\\"Encountered init, can't save\\\");\\r\\n            callback(this.initError);\\r\\n            return false;\\r\\n        }\\r\\n        const saverStyle = getSaverStyle(this.wiki);\\r\\n        let savePromise;\\r\\n        switch (saverStyle) {\\r\\n            case SaverStyle.SingleFile:\\r\\n                savePromise = this.saveFile(text);\\r\\n                break;\\r\\n            case SaverStyle.SingleFileVersionBackup:\\r\\n                savePromise = this.saveWithDirBackup(text);\\r\\n                break;\\r\\n            default:\\r\\n                callback(`Unsupported SaverStyle: [${saverStyle}]`);\\r\\n                return false;\\r\\n        }\\r\\n        savePromise.then(() => {\\r\\n            logDebug(\\\"Successfully saved to file system\\\");\\r\\n            callback(null);\\r\\n        }, err => {\\r\\n            problemEncountered = true;\\r\\n            logDebug(\\\"Encountered error while saving: %o\\\", err);\\r\\n            callback(`Encountered error while saving to file system: [${err}]`);\\r\\n        });\\r\\n        return true;\\r\\n    }\\r\\n    reset() {\\r\\n        logDebug(\\\"Reseting file saver...\\\");\\r\\n        try {\\r\\n            window.indexedDB.deleteDatabase(DB_NAME);\\r\\n        }\\r\\n        catch (err) {\\r\\n            logDebug(\\\"Failed to delete file save location: %o\\\", err);\\r\\n        }\\r\\n        setupLogging(this.wiki);\\r\\n        this.fileHandle = undefined;\\r\\n        this.initError = null;\\r\\n        this.prevPageHash = undefined;\\r\\n        logDebug(\\\"Reset file save location.\\\");\\r\\n    }\\r\\n}\\r\\n// Has one parameter, wiki if necessary\\r\\nconst canSave = (handler) => {\\r\\n    try {\\r\\n        setupLogging(handler.wiki);\\r\\n        return isEnabled(handler.wiki) && (!!window.showOpenFilePicker) && window.isSecureContext && !problemEncountered;\\r\\n    }\\r\\n    catch (err) {\\r\\n        logDebug(err);\\r\\n        return false;\\r\\n    }\\r\\n};\\r\\nlet currentSaver = null;\\r\\n// Also has access to wiki if necessary\\r\\nconst create = (wiki) => {\\r\\n    const result = new FileSystemSaver(wiki);\\r\\n    currentSaver = result;\\r\\n    // Wait one event cycle before trying to show the welcome page.\\r\\n    window.setTimeout(() => {\\r\\n        if (wiki.getTiddler(PLUGIN_SETTINGS_DATA).getFieldString(SHOW_WELCOME_MODAL_FIELD) === YES) {\\r\\n            logDebug(\\\"Showing welcome modal.\\\");\\r\\n            const modal = window.$tw.modal;\\r\\n            modal.display(WELCOME_PAGE);\\r\\n        }\\r\\n        else {\\r\\n            logDebug(\\\"Not showing welcome modal since it is not enabled.\\\");\\r\\n        }\\r\\n    }, 0);\\r\\n    return result;\\r\\n};\\r\\nmodule.exports = {\\r\\n    canSave,\\r\\n    create,\\r\\n    getCurrentSaver: () => currentSaver\\r\\n};\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"saver\"},\"$:/plugins/slaymaker1907/browser-nativesaver/settings-data\":{\"title\":\"$:/plugins/slaymaker1907/browser-nativesaver/settings-data\",\"enable-logging?\":\"no\",\"enable-saver?\":\"yes\",\"check-consistency?\":\"yes\",\"allow-indexedDB?\":\"no\",\"wiki-file-name\":\"\",\"show-welcome-modal?\":\"yes\"},\"$:/plugins/slaymaker1907/browser-nativesaver/settings\":{\"title\":\"$:/plugins/slaymaker1907/browser-nativesaver/settings\",\"tags\":\"$:/tags/ControlPanel/Saving\",\"caption\":\"HTML Native File System Saver\",\"text\":\"<$set name=\\\"nativeSaverSettings\\\" value=<<nativeSaverSettings>> emptyValue=\\\"$:/plugins/slaymaker1907/browser-nativesaver/settings-data\\\">\\r\\n<$nativesavercontroller>\\n\\n<$checkbox tiddler=<<nativeSaverSettings>> field=\\\"enable-saver?\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\"\\r\\n    default=\\\"yes\\\"> Enable saver?</$checkbox>\\n\\n<$checkbox tiddler=<<nativeSaverSettings>> field=\\\"show-welcome-modal?\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"yes\\\"> Show welcome modal?</$checkbox>\\n\\n<$checkbox tiddler=<<nativeSaverSettings>> field=\\\"enable-logging?\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"> Enable debug logging?</$checkbox>\\n\\n<$checkbox tiddler=<<nativeSaverSettings>> field=\\\"allow-indexedDB?\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"> Allow FS to use indexedDB? (some security issues since everything on file:// has the same origin)</$checkbox>\\n\\n<$checkbox tiddler=<<nativeSaverSettings>> field=\\\"check-consistency?\\\" checked=\\\"yes\\\" unchecked=\\\"no\\\" default=\\\"no\\\"> Check consistency to avoid parallel writes?</$checkbox>\\n\\n<$select tiddler=<<nativeSaverSettings>> field=\\\"save-style\\\" default=\\\"single-file\\\">\\r\\n    <option value=\\\"single-file\\\">Single file</option>\\r\\n    <option value=\\\"single-file-version-backup\\\">Single file with versioned backups (all stored in a single directory)</option>\\r\\n</$select>\\n\\n<$reveal type=\\\"match\\\" stateTitle=<<nativeSaverSettings>> stateField=\\\"save-style\\\" text=\\\"single-file-version-backup\\\">\\r\\n    Wiki file name (same as download saver if empty): <$edit-text tiddler=\\\"$:/plugins/slaymaker1907/browser-nativesaver/settings-data\\\" field=\\\"wiki-file-name\\\" />\\r\\n</$reveal>\\n\\n<$button onclick=\\\"window.indexedDB.deleteDatabase('FileHandles-QqiTNHy4qkN9TtIYbd5i');\\\">\\r\\n<$action-sendmessage $message=\\\"ns-reset-file-saver\\\" />\\r\\nReset file save location\\r\\n</$button>\\n\\n</$nativesavercontroller>\\r\\n</$set>\\r\\n\"},\"$:/plugins/slaymaker1907/browser-nativesaver/sync-adaptor.js\":{\"title\":\"$:/plugins/slaymaker1907/browser-nativesaver/sync-adaptor.js\",\"text\":\"/*\\\\\\r\\ntitle: $:/plugins/slaymaker1907/browser-nativesaver/sync-adaptor.js\\r\\ntype: application/javascript\\r\\nmodule-type: syncadaptor\\r\\n\\r\\nAdaptor for saving individual servers in a directory\\r\\n\\r\\n\\\\*/\\r\\nconst saver = require(\\\"$:/plugins/slaymaker1907/browser-nativesaver/saver.js\\\");\\r\\n\\r\\nconst isNode = (typeof window) === \\\"undefined\\\";\\r\\n\\r\\n// Don't expose syncadaptor unless we are in the browser.\\r\\n// Can also disable the adaptor completely by commenting this out.\\r\\nif (!isNode) {\\r\\n\\tmodule.exports = {\\r\\n\\t\\tadaptorClass: saver.syncAdaptor\\r\\n\\t};\\r\\n}\\r\\n\",\"type\":\"application/javascript\",\"module-type\":\"syncadaptor\"},\"$:/plugins/slaymaker1907/browser-nativesaver/welcome\":{\"title\":\"$:/plugins/slaymaker1907/browser-nativesaver/welcome\",\"tags\":\"\",\"text\":\"\\\\define tmSaveWikiHelper()\\r\\n<!-- <$action-sendmessage $message=\\\"tm-save-tiddler\\\" $param=\\\"$:/plugins/slaymaker1907/browser-nativesaver/welcome/settings-data\\\" /> -->\\r\\n<$action-sendmessage $message=\\\"tm-save-wiki\\\" $ />\\r\\n<$action-sendmessage $message=\\\"tm-close-tiddler\\\" />\\r\\n\\\\end\\n\\n! HTML Native File System Saver\\n\\nWe require a click event to start the save dialogue.\\n\\n<$button style=\\\"font-size: 1.5em; width: 15em\\\" actions=<<tmSaveWikiHelper>> >Save</$button>\\n\\n<br>\\r\\n<hr>\\n\\n! Settings\\n\\n<!-- <$vars nativeSaverSettings=\\\"$:/plugins/slaymaker1907/browser-nativesaver/welcome/settings-data\\\"> -->\\r\\n{{$:/plugins/slaymaker1907/browser-nativesaver/settings}}\\r\\n<!-- </$vars> -->\\r\\n\"}}}"}